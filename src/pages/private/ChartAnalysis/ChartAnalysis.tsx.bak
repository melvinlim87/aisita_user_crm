import React, { useState, useEffect } from 'react';
import ChartUpload from '@components/chart/ChartUpload';
import ChatInterface from '@components/chat/ChatInterface';
import { useAuth } from '@contexts/AuthContext';
import { BarChart2, Upload, X } from 'lucide-react';
import { ChatProvider, useChat } from '@contexts/ChatContext';
import { META_TEXT_GRADIENT } from '@/constants';
import { postRequest, getRequest } from '@/services/apiRequest';
import { useParams } from 'react-router-dom';

const ChartAnalysisContent: React.FC = () => {
  const { user } = useAuth();
  const { sendMessage, selectedModel, currentConversation, startNewConversation, clearConversation } = useChat();
  const [chartFile, setChartFile] = useState<File | null>(null);
  const [chartPreview, setChartPreview] = useState<string | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const [historyLoaded, setHistoryLoaded] = useState(false);
  
  // Get the analysis ID from URL params if it exists
  const { id: analysisId } = useParams<{ id?: string }>();
  
  // Function to load analysis history
  const loadAnalysisHistory = async (id: string) => {
    try {
      setIsLoadingHistory(true);
      // Clear any existing conversation before loading history
      clearConversation();
      
      const response = await getRequest<any>(`/history/${id}`);
      console.log('Loaded analysis history:', response);
      
      if (response) {
        // Set chart preview if available
        if (response.chart_urls && response.chart_urls.length > 0) {
          const chartUrl = response.chart_urls[0];
          setChartPreview(chartUrl);
          localStorage.setItem('chartPreview', chartUrl);
        }
        
        // Start a new conversation with the analysis ID
        startNewConversation(id);
        
        // If there are chat messages, recreate them in the current conversation
        if (response.chat_messages && response.chat_messages.length > 0) {
          // Sort messages by timestamp if available
          const sortedMessages = [...response.chat_messages].sort((a, b) => {
            const aTime = a.timestamp || a.created_at || 0;
            const bTime = b.timestamp || b.created_at || 0;
            return new Date(aTime).getTime() - new Date(bTime).getTime();
          });
          
          // Process each message sequentially
          for (const msg of sortedMessages) {
            const content = msg.text || msg.content || '';
            const sender = msg.sender || (msg.role === 'assistant' ? 'ai' : 'user');
            
            // Add message to conversation using sendMessage
            // Use isAiResponse=true for AI messages to prevent making API calls
            await sendMessage(
              content,
              selectedModel || 'default-model', // Provide fallback if model is null
              sender === 'ai' || sender === 'assistant',
              false // Not loading
            );
          }
        }
        
        setHistoryLoaded(true);
      }
    } catch (error) {
      console.error('Failed to load analysis history:', error);
    } finally {
      setIsLoadingHistory(false);
    }
  };
  
  // Load analysis history when ID is present in URL
  useEffect(() => {
    if (analysisId && !historyLoaded) {
      loadAnalysisHistory(analysisId);
    }
  }, [analysisId, historyLoaded, selectedModel]); // Include selectedModel in dependencies
  
  // Display loading indicator if analysis history is being loaded
  useEffect(() => {
    if (currentConversation && historyLoaded && analysisId) {
      // Log successful loading of history
      console.log(`Successfully loaded analysis history for ID: ${analysisId}`);
    }
  }, [currentConversation, historyLoaded, analysisId]);

  // Load saved chart preview from localStorage on component mount
  useEffect(() => {
    const savedChartPreview = localStorage.getItem('chartPreview');
    if (savedChartPreview) {
      setChartPreview(savedChartPreview);
      
      // Dispatch custom event to notify other components that chart is loaded
      setTimeout(() => {
        const event = new CustomEvent('chartPreviewUpdate', { detail: { hasChart: true } });
        window.dispatchEvent(event);
      }, 100);
    }
    
    // Listen for conversation clear events
    const handleConversationClear = () => {
      console.log('Clearing chart preview from ChartAnalysis component');
      setChartPreview(null);
      setChartFile(null);
      setIsAnalyzing(false);
    };
    
    // Use a specific event name for clearing chart from conversation clear
    window.addEventListener('clearChartFromConversation', handleConversationClear);
    
    return () => {
      window.removeEventListener('clearChartFromConversation', handleConversationClear);
    };
  }, []);
  
  // Save chart preview to localStorage whenever it changes
  useEffect(() => {
    if (chartPreview) {
      localStorage.setItem('chartPreview', chartPreview);
      // Dispatch custom event to notify other components
      const event = new Event('chartPreviewUpdate');
      window.dispatchEvent(event);
    } else if (chartPreview === null && localStorage.getItem('chartPreview')) {
      // If chart preview is explicitly set to null (i.e., cleared), remove from localStorage
      localStorage.removeItem('chartPreview');
      // Dispatch custom event to notify other components
      const event = new Event('chartPreviewUpdate');
      window.dispatchEvent(event);
    }
  }, [chartPreview]);

  const handleUpload = (file: File) => {
    console.log('File selected:', {
      name: file.name,
      type: file.type,
      size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
    });
    
    // Set analyzing to true immediately when upload starts
    setIsAnalyzing(true);

    // Validate file size (max 5MB)
    const maxSize = 5 * 1024 * 1024; // 5MB in bytes
    if (file.size > maxSize) {
      alert('File is too large. Maximum size is 5MB.');
      setIsAnalyzing(false); // Reset analyzing state
      return;
    }

    // Validate file type
    if (!file.type.startsWith('image/')) {
      alert('Please upload an image file.');
      setIsAnalyzing(false); // Reset analyzing state
      return;
    }

    setChartFile(file);
    
    // Use FileReader only for preview purposes
    const reader = new FileReader();
    reader.onerror = () => {
      alert('Error reading file. Please try again.');
      setIsAnalyzing(false);
    };
    
    reader.onload = (e) => {
      const base64Result = e.target?.result as string;
      if (base64Result) {
        setChartPreview(base64Result);
        // Also directly update localStorage here to ensure it's saved immediately
        localStorage.setItem('chartPreview', base64Result);
        // Dispatch custom event right away
        const event = new Event('chartPreviewUpdate');
        window.dispatchEvent(event);
        
        // Now process the file upload after preview is set
        processFileUpload(file);
      } else {
        alert('Error generating preview. Please try again.');
        setIsAnalyzing(false);
      }
    };
    
    // Read as data URL only for preview purposes
    reader.readAsDataURL(file);
  };
  
  // Separate function to handle the actual file upload
  const processFileUpload = async (file: File) => {
    try {
      // Loading indicator is already set in handleUpload
      
      if (!selectedModel) {
        throw new Error('Please select a model first');
      }
      
      // Create FormData to send the file
      const formData = new FormData();
      formData.append('image', file);
      formData.append('modelId', selectedModel);
      
      // Log request payload for debugging
      console.log('Sending request with:', {
        modelId: selectedModel,
        fileName: file.name,
        fileType: file.type,
        fileSize: `${(file.size / 1024 / 1024).toFixed(2)}MB`
      });
      
      // Define interface for the response data
      interface AnalysisResponse {
        history_id?: number;
        Symbol?: string;
        Timeframe?: string;
        Current_Price?: string;
        Market_Structure?: string;
        Key_Price_Levels?: {
          Support_Levels?: string[];
          Resistance_Levels?: string[];
        };
        Entry_Price?: string;
        Stop_Loss?: string;
        Take_Profit?: string;
        Technical_Justification?: string;
        Risk_Assessment?: {
          Invalidation_Scenarios?: string;
          Key_Risk_Levels?: string;
        };
        Analysis_Confidence?: {
          Confidence_Level_Percent?: number;
        };
      }
      
      // Use the existing postRequest function with FormData
      const data = await postRequest<AnalysisResponse>('/openrouter/analyze-image', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      
      if (!data) {
        throw new Error('No response received from the server');
      }
      
      // Save history_id to a new localStorage item if available
      if (data.history_id) {
        console.log('Saving chart analysis history_id:', data.history_id);
        localStorage.setItem('chartAnalysisHistoryId', data.history_id.toString());
      }
      
      // Format the analysis data into a readable message
      const analysis = formatAnalysis(data);
      await sendMessage(analysis, selectedModel, true);
    } catch (error: any) {
      console.error('Failed to analyze image:', error);
      console.log('Error details:', {
        status: error.response?.status,
        data: error.response?.data,
        message: error.message
      });
      const errorMessage = error.response?.data?.error || error.message || 'Failed to analyze image';
      alert(errorMessage);
    } finally {
      setIsAnalyzing(false);
    }
  };

  // Function to clear the current chart
  const clearCurrentChart = () => {
    setChartPreview(null);
    localStorage.removeItem('chartPreview');
    localStorage.removeItem('chartAnalysisHistoryId');
    // Notify other components about the change
    window.dispatchEvent(new Event('chartPreviewUpdate'));
  };
  
  return (
    <div className="container mx-auto p-6">
      {/* Loading overlay for history */}
      {isLoadingHistory && (
        <div className="fixed inset-0 bg-black/70 z-50 flex items-center justify-center">
          <div className="bg-[#1a1a20] p-6 rounded-lg shadow-lg border border-[#3a3a45] max-w-md w-full">
            <div className="flex flex-col items-center">
              <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-white mb-4"></div>
              <p className="text-xl font-semibold text-white">Loading analysis history...</p>
            </div>
          </div>
        </div>
      )}
      {/* Header Section */}
      <div className="bg-[#1a1a20] rounded-lg border border-[#3a3a45] p-6 mb-6">
        <h1 className={`text-2xl font-bold ${META_TEXT_GRADIENT} mb-2`}>
          Chart Analysis
        </h1>
        <p className="text-gray-400">
          Upload your financial chart to receive AI-powered analysis of patterns, indicators, and trading strategies
        </p>
      </div>
      
      {/* Main Content */}
      <div className="flex flex-col md:flex-row gap-6">
        {/* Left Panel (60%) - Chart Section */}
        <div className="w-full md:w-3/5 bg-[#1a1a20] p-6 rounded-lg border border-[#3a3a45]">
          <div className="h-full flex flex-col">
            {chartPreview ? (
              <div className="flex-1 flex flex-col">
                <div className="bg-[#25252d] p-4 rounded-lg border border-[#3a3a45] mb-4 relative">
                  {isAnalyzing && (
                    <div className="absolute inset-0 bg-black/50 flex items-center justify-center rounded-lg z-50">
                      <div className="flex flex-col items-center">
                        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-white mb-2"></div>
                        <div className="text-white text-sm font-medium">Analyzing chart...</div>
                      </div>
                    </div>
                  )}
                  <div className="max-w-md mx-auto mb-4 rounded-lg overflow-hidden shadow-lg relative">
                    <img src={chartPreview} alt="Chart Preview" className="w-full h-auto" />
                    <button 
                      onClick={clearCurrentChart}
                      className="absolute top-2 right-2 p-1 bg-red-500 rounded-full text-white hover:bg-red-600 transition-colors"
                      aria-label="Clear chart"
                      title="Clear current chart"
                    >
                      <X size={16} />
                    </button>
                  </div>
                </div>
                
                <div className="mt-auto">
                  <ChartUpload onUpload={handleUpload} />
                </div>
              </div>
            ) : (
              <div className="flex-1 flex items-center justify-center py-8">
                <div className="max-w-md w-full">
                  <div className="text-center mb-8">
                    <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-[#25252d] mb-4">
                      <Upload className={`w-8 h-8 ${META_TEXT_GRADIENT}`} />
                    </div>
                    <h2 className="text-xl font-semibold mb-2">
                      Upload a Financial Chart
                    </h2>
                    <p className="text-gray-400">
                      Get AI-powered analysis of patterns, indicators, and trading strategies
                    </p>
                  </div>
                  
                  <ChartUpload onUpload={handleUpload} />
                </div>
              </div>
            )}
          </div>
        </div>
          
        {/* Right Panel (40%) - Chat Interface */}
        <div className="w-full md:w-2/5 bg-[#1a1a20] rounded-lg border border-[#3a3a45] h-[600px] md:h-auto overflow-hidden">
          <ChatInterface />
        </div>
      </div>
    </div>
  );
};

const ChartAnalysis: React.FC = () => (
  <ChatProvider>
    <ChartAnalysisContent />
  </ChatProvider>
);

// Format the analysis data into a readable message
const formatAnalysis = (data: any): string => {
  const sections = [];

  // Basic Info
  sections.push(`**${data.Symbol} ${data.Timeframe} Analysis**`);
  sections.push(`Current Price: ${data.Current_Price}`);

  // Market Structure
  if (data.Market_Structure) {
    sections.push(`\n**Market Structure**\n${data.Market_Structure}`);
  }

  // Price Levels
  if (data.Key_Price_Levels) {
    const levels = data.Key_Price_Levels;
    sections.push('\n**Key Price Levels**');
    if (levels.Support_Levels?.length) {
      sections.push(`- Support: ${levels.Support_Levels.join(', ')}`);
    }
    if (levels.Resistance_Levels?.length) {
      sections.push(`- Resistance: ${levels.Resistance_Levels.join(', ')}`);
    }
  }

  // Trade Setup
  sections.push('\n**Trade Setup**');
  sections.push(`- Entry: ${data.Entry_Price}`);
  sections.push(`- Stop Loss: ${data.Stop_Loss}`);
  sections.push(`- Take Profit: ${data.Take_Profit}`);

  // Technical Analysis
  if (data.Technical_Justification) {
    sections.push(`\n**Technical Justification**\n${data.Technical_Justification}`);
  }

  // Risk Assessment
  if (data.Risk_Assessment) {
    sections.push('\n**Risk Assessment**');
    if (data.Risk_Assessment.Invalidation_Scenarios) {
      sections.push(`- Invalidation: ${data.Risk_Assessment.Invalidation_Scenarios}`);
    }
    if (data.Risk_Assessment.Key_Risk_Levels) {
      sections.push(`- Key Risk Levels: ${data.Risk_Assessment.Key_Risk_Levels}`);
    }
  }

  // Confidence Score
  if (data.Analysis_Confidence?.Confidence_Level_Percent) {
    sections.push(`\n**Analysis Confidence**\n${data.Analysis_Confidence.Confidence_Level_Percent}%`);
  }

  return sections.join('\n');
};

export default ChartAnalysis;